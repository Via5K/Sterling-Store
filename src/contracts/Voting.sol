// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;
import "./NFT.sol";

//NEW INSTRUCTIONS TO DO
//NFT MAI MAPPING BANAYI HAI DIFFERNT TYPES KI,
// TO SABSE PHLE CHECK KRNA KI VOTE KR SKTA HAI YA NAHI BY USING MAPPING.
// USKE BD USS NFT KO HARR MAPPING SE HATA DO YA FIR FALSE KRDO...AUR NAI TO CONTRACT ADDRESS PE TRANSFER KRNA HAI DIRECT...
// TRANSFER FROM FUNCTION BHI BANANA HAI, JISME SE KI, JB TRANSFER HOTO SARI MAPPING UPDATE HO JAYE.
// AND LAST BUT NOT THE LEAST, JAISE HE VOTE HO TB NFT TRANSFER HONI CHAHIUE.
contract Voting {
    NFT nft_;

    constructor(NFT _nft) {
        nft_ = _nft;
    }

    struct participants {
        //this will be the name of the voting that is being conducted....
        string votingName;
        //votingStarted tells wether the voting has started or not?
        bool votingStarted;
        //resultDeclared makes sure that this voting is not again accessed once its result has been declared.
        bool resultDeclared;
        //owner of the current voting
        address owner;
        //voteCount
        mapping(string => uint256) voteCount;
        //hasVoted
        mapping(address => bool) hasVoted;
        //votedFro
        mapping(address => string) votedFor;
        //array for all the participants or the choices available to vote...
        string[] choices;
    }
    /*****
    This mapping contains the 
    parameters:
    string => whereinm this will be id and each id will be uniquely generated by frontend.
    participants => structure wherein, we are creating a new participants and each new will have new variables.
    *****/
    mapping(string => participants) public votingRecord;

    //all the previous winners i.e id => nameOfWinner => VotedRecieved
    mapping(string => mapping(string => uint256)) previousWinners;

    //mapping wherein, we store all the active votings and when a result is declared, we remove that voting from mapping.
    //id=>bool
    mapping(string => bool) activeVotingMap;

    //stores the active voting _id
    string[] activeVoting;

    //stores the id and its index... Index is based on the activeVoting Array.
    //id=>index in array...
    mapping(string => uint256) activeVotingIndex;

    //takes index and returns the id of the voting present at that index.
    //Returns the id of the active votings....
    //was named as activeVotings make sure to change in js file also once this is dpeloyed again
    function findActiveVotingsId(uint256 _index)
        public
        view
        returns (string memory)
    {
        return activeVoting[_index];
    }

    //return active voting array's length...
    function activeVotingLength() public view returns (uint256) {
        return activeVoting.length;
    }

    function getVotingName(string memory _tokenId)
        public
        view
        returns (string memory)
    {
        return votingRecord[_tokenId].votingName;
    }

    /*****
    eligibleToVote : checks if the current user is eligible to vote in this voting or not?
    parameters:
    _id: this is the voting id, i.e for which voting is the person trying to vote
    _voter: this is the address of the person who is voting
    parameters:
    *****/
    modifier eligibleToVote(string memory _id, address _voter) {
        require(
            votingRecord[_id].hasVoted[_voter] == false,
            "You have already casted a vote!!"
        );
        _;
    }

    /*****
    votingStatus : modifier makes sure that once voting has started, no-one can add new participants.
    parameters:
    _id
    *****/
    modifier votingStatus(string memory _id) {
        require(
            votingRecord[_id].votingStarted == false,
            "Cannot Add New choices, because the voting has already started!!!"
        );
        _;
    }
    /*****
    onlyOwner : modifier makes sure that Only owner can stop the voting.
    parameters:
    _id
    *****/
    modifier onlyOwner(string memory _id) {
        require(
            votingRecord[_id].owner == msg.sender,
            "You need to be the owner to declare the results.."
        );
        _;
    }

    /***** 
    createNewVoting: Created new voting instance, meaning a new voting is started.
    parameters:
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    _votingName: name of the current voting.
    *****/

    function createNewVoting(string memory _id, string memory _votingName)
        public
    {
        // participants storage newParticipant = votingRecord[_id];
        // votingRecord[_id] = newParticipant;
        votingRecord[_id].votingName = _votingName;
        votingRecord[_id].votingStarted = false;
        votingRecord[_id].owner = msg.sender;
        votingRecord[_id].resultDeclared = false;
        activeVoting.push(_id); //push at the last.
        activeVotingMap[_id] = true; //marking true of id in active votings...
        activeVotingIndex[_id] = activeVoting.length - 1; //store the id=>index
    }

    /***** 
    addChoices: Adds the participants in the choice only when the voting has not started, once it has started, it cannot be reversed back.
    parameters:
    Also only the owner of this voting can add new participants.
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    _contestant: is the choices that we are going to get.
    *****/
    function addChoices(string memory _id, string memory _contestant)
        public
        votingStatus(_id)
    {
        require(
            votingRecord[_id].owner == msg.sender,
            "You need the entity that started voting to add new participants"
        );
        //makes sure that the voting has not been ended.
        require(
            votingRecord[_id].resultDeclared == false,
            "You cannot add a new choice as, Result is already declared..."
        );
        votingRecord[_id].choices.push(_contestant);
    }

    /***** 
    viewChoices: is the function that returns all the choices available for the voting.
    parameters:
    
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    Returns:
    string[] memory: Returns all the choices available for that id.
    *****/

    function viewChoices(string memory _id)
        public
        view
        returns (string[] memory)
    {
        return votingRecord[_id].choices;
    }

    /***** 
    newVote: Casts a new vote in the voting after checking if it is valid.
    parameters:
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    _contestant: is the choices that we are going to get.
    *****/

    //can also use indexing (like 0,1,2,3) but just to be on safer side using the string itself. ||Can be applied
    //uint _till should either be fixed or dynamic for the time being i am commenting the code.
    // , uint _till
    function newVote(string memory _id, string memory _votedFor)
        public
        eligibleToVote(_id, msg.sender)
    {
        require(
            votingRecord[_id].votingStarted == true,
            "Voting has not started Yet..."
        );
        //makes sure that the voting has not been ended.
        require(
            votingRecord[_id].resultDeclared == false,
            "You cannot cast the vote, Result is already declared..."
        );
        //calling len function because we cannot directly acess mapping. So have created functions for it.
        //make sure that person has NFT....
        require(
            nft_.AllSpecialNFTLength(msg.sender) > 0,
            "Please own a Special NFT in order to Caste your Vote"
        );
        // nft_.StakeSpecialNFT(msg.sender, _till);
        nft_.StakeSpecialNFT(msg.sender, block.timestamp + 100);
        votingRecord[_id].hasVoted[msg.sender] = true;
        votingRecord[_id].votedFor[msg.sender] = _votedFor;
        votingRecord[_id].voteCount[_votedFor] += 1;
    }

    /***** 
    startVoting: Starts the voting if it has not already been started
    parameters:
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    *****/

    function startVoting(string memory _id) public {
        require(
            msg.sender == votingRecord[_id].owner,
            "You cannot start the voting. You need the owner of this voting."
        );
        require(
            votingRecord[_id].votingStarted == false,
            "Voting has already started."
        );
        votingRecord[_id].votingStarted = true;
        activeVoting.push(_id); //push at the last.
        activeVotingMap[_id] = true; //marking true of id in active votings...
        activeVotingIndex[_id] = activeVoting.length - 1; //store the id=>index
    }

    /***** 
    checkResult: Returns the winner with the votes that he has recieved.
    parameters:
    _id: id generated from the frontend, which is eventually storing all the voting for this voting instance.
    returns: name of the winner, and the votes recieved..
    *****/
    function checkResult(string memory _id)
        public
        onlyOwner(_id)
        returns (string memory, uint256)
    {
        votingRecord[_id].resultDeclared = true; //updating the resultDecalred Counter
        uint256 ans = 0;
        string memory winner = "";

        for (uint256 i = 0; i < votingRecord[_id].choices.length; i++) {
            // string memory temp = votingRecord[_id].voteCount[votingRecord[_id].choices[i]];
            if (
                ans < votingRecord[_id].voteCount[votingRecord[_id].choices[i]]
            ) {
                ans = votingRecord[_id].voteCount[votingRecord[_id].choices[i]];
                winner = votingRecord[_id].choices[i];
            }
        }
        // this makes sure that party with no name does not get entereed in the map.
        // this same can also be checked using ans variable i.e if it is 0, then do not enter.
        if (
            keccak256(abi.encodePacked(winner)) ==
            keccak256(abi.encodePacked(""))
        ) {
            return (winner, ans);
        }
        activeVotingMap[_id] = false; //firstly the voting is not active,
        //now remove this id from the array...
        uint256 _index = activeVotingIndex[_id]; //find the index
        activeVotingIndex[activeVoting[activeVoting.length - 1]] = _index; //now change the index because we are not directly deleting but using swapping and then removing the voting from th elast..
        activeVoting[_index] = activeVoting[activeVoting.length - 1]; //swap
        activeVoting.pop(); //delete

        //updates the past winners
        previousWinners[_id][winner] = ans;
        return (winner, ans);
    }
}
